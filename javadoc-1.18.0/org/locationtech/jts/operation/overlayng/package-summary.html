<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_261) on Wed Dec 23 10:14:23 EST 2020 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>org.locationtech.jts.operation.overlayng (org.locationtech.jts:jts-core 1.18.0 API)</title>
<meta name="date" content="2020-12-23">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="org.locationtech.jts.operation.overlayng (org.locationtech.jts:jts-core 1.18.0 API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">org.locationtech.jts:jts-core 1.18.0</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/locationtech/jts/operation/overlay/validate/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../org/locationtech/jts/operation/polygonize/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/locationtech/jts/operation/overlayng/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;org.locationtech.jts.operation.overlayng</h1>
<div class="docSummary">
<div class="block">
Contains classes that perform vector overlay 
to compute boolean set-theoretic spatial functions.</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../org/locationtech/jts/operation/overlayng/CoverageUnion.html" title="class in org.locationtech.jts.operation.overlayng">CoverageUnion</a></td>
<td class="colLast">
<div class="block">Unions a valid coverage of polygons or lines
 in an efficient way.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../org/locationtech/jts/operation/overlayng/FastOverlayFilter.html" title="class in org.locationtech.jts.operation.overlayng">FastOverlayFilter</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../org/locationtech/jts/operation/overlayng/LineLimiter.html" title="class in org.locationtech.jts.operation.overlayng">LineLimiter</a></td>
<td class="colLast">
<div class="block">Limits the segments in a list of segments
 to those which intersect an envelope.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../org/locationtech/jts/operation/overlayng/OverlayNG.html" title="class in org.locationtech.jts.operation.overlayng">OverlayNG</a></td>
<td class="colLast">
<div class="block">Computes the geometric overlay of two <a href="../../../../../org/locationtech/jts/geom/Geometry.html" title="class in org.locationtech.jts.geom"><code>Geometry</code></a>s, 
 using an explicit precision model to allow robust computation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../org/locationtech/jts/operation/overlayng/OverlayNGRobust.html" title="class in org.locationtech.jts.operation.overlayng">OverlayNGRobust</a></td>
<td class="colLast">
<div class="block">Performs an overlay operation using <a href="../../../../../org/locationtech/jts/operation/overlayng/OverlayNG.html" title="class in org.locationtech.jts.operation.overlayng"><code>OverlayNG</code></a>, 
 providing full robustness by using a series of
 increasingly robust (but slower) noding strategies.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../org/locationtech/jts/operation/overlayng/PrecisionReducer.html" title="class in org.locationtech.jts.operation.overlayng">PrecisionReducer</a></td>
<td class="colLast">
<div class="block">Functions to reduce the precision of a geometry
 by rounding it to a given precision model.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../org/locationtech/jts/operation/overlayng/PrecisionUtil.html" title="class in org.locationtech.jts.operation.overlayng">PrecisionUtil</a></td>
<td class="colLast">
<div class="block">Functions for computing precision model scale factors
 that ensure robust geometry operations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../org/locationtech/jts/operation/overlayng/RingClipper.html" title="class in org.locationtech.jts.operation.overlayng">RingClipper</a></td>
<td class="colLast">
<div class="block">Clips rings of points to a rectangle.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../org/locationtech/jts/operation/overlayng/UnaryUnionNG.html" title="class in org.locationtech.jts.operation.overlayng">UnaryUnionNG</a></td>
<td class="colLast">
<div class="block">Unions a collection of geometries in an
 efficient way, using <a href="../../../../../org/locationtech/jts/operation/overlayng/OverlayNG.html" title="class in org.locationtech.jts.operation.overlayng"><code>OverlayNG</code></a>
 to ensure robust computation.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package org.locationtech.jts.operation.overlayng Description">Package org.locationtech.jts.operation.overlayng Description</h2>
<div class="block"><p>
Contains classes that perform vector overlay 
to compute boolean set-theoretic spatial functions.
Overlay operations are used in spatial analysis for computing set-theoretic 
operations (boolean combinations) of input <code>Geometry</code>s.
</p>
<p>
The <code>OverlayNG</code> class provides the standard Simple Features 
boolean set-theoretic overlay operations.
These are:
<ul>
<li><b>Intersection</b> - all points which lie in both geometries</li>
<li><b>Union</b> - all points which lie in at least one geometry</li>
<li><b>Difference</b> - all points which lie in the first geometry but not the second</li>
<li><b>Symmetric Difference</b> - all points which lie in one geometry but not both</li>
</ul>
These operations are supported for all combinations of the basic geometry types and their homogeneous collections.
<p>
Additional operations include:
<ul>
<li><code>UnaryUnion</code> unions collections of geometries in an efficient way</li>
<li><code>CoverageUnion</code> provides enhanced performance for unioning
valid polygonal and lineal coverages</li>
<li><code>PrecisionReducer</code> allows reducing the precision of a geometry
in a topologically-valid way</li>
</ul>
</p>
<p>
<h2>Semantics</h2>
The requirements for overlay input are:

<ul>
<li>Input geometries may have different dimension.</li>
<li>Collections must be homogeneous
  (all elements must have the same dimension).</li>
<li>In general, inputs must be valid geometries.</li>
<li>However, polygonal inputs may contain the following two kinds of "mild" invalid topology: 
  <ul>
  <li>rings which self-touch at discrete points (sometimes called inverted shells and exverted holes).</li>
  <li>rings which touch along line segments (i.e. topology collapse).</li>
  </ul>
</li>
</ul>

<p>
The semantics of overlay output are:

<ul>
<li>Results are always valid geometries. 
  In particular, result <code>MultiPolygon</code>s are valid.</li>
<li>Repeated vertices are removed.</li>
<li>Linear results include all nodes (endpoints) present in the input.
  In some cases more nodes will be present.
  (If merged lines are required see <code>LineMerger</code>.)</li>
<li>Polygon edges which undergo topology collapse to lines 
  (due to rounding or snapping) are included in the result.
  This means that all operations may produce a heterogeneous result.
  Usually this only occurs when using a fixed-precision model,
  but it can happen due to snapping performed to improve robustness.
  </li>
<li>The <code>intersection</code> operation result includes
  all components of the intersection
  for geometries which intersect in components of the same and/or lower dimension.</li>
<li>The <code>difference</code> operation produces a homogeneous result 
  if no topology collapses are present. 
  In this case the result dimension is equal to that of the left-hand operand.</li>
<li>The <code>union</code> and <code>symmetric difference</code> operations
  may produce a heterogeneous result if the inputs are of mixed dimension.</li>
<li>Homogeneous results are output as <code>Multi</code> geometries.</li>
<li>Heterogeneous results are output as a <code>GeometryCollection</code>
  containing a set of atomic geometries.  
  (This provides backwards compatibility with the original overlay implementation.
  However, it loses the information that the polygonal results 
  have valid <code>MultiPolygon</code> topology.)</li>
<li>Empty results are atomic <code>EMPTY</code> geometries 
  of dimension appropriate to the operation.</li>
</ul>

</p>
<h2>Features</h2>
<h3>Functionality</h3>
<ul>
<li><b>Precision Model</b> - operations are performed using a defined precision model
(finite or floating)
<li><b>Robust Computation</b> - provides fully robust computation when an appropriate noder is used
<li><b>Performance optimizations</b> - including:
  <ul>
  <li>Short-circuiting for disjoint input envelopes
  <li>Reduction of input segment count via clipping / limiting to overlap envelope
  <li>Optimizations can be disabled if required (e.g. for testing or performance evaluation)
  </ul>
<li><b>Pluggable Noding</b> - allows using different noders to change characteristics of performance and accuracy
<li><b>Precision Reduction</b> - in a topologically correct way.  
Implemented by unioning a single input with an empty geometry
<li><b>Topology Correction / Conversion</b> - handles certain kinds
of polygonal inputs which are invalid
<li><b>Fast Coverage Union</b> - of valid polygonal and linear coverages
</ul>

<h3>Pluggable Noding</h3>

The noding phase of overlay uses a  <code>Noder</code> subclass.
This is determine automatically based on the precision model of the input.
Or it can be provided explicity, which allows changing characteristics
of performance and robustness.
Examples of relevant noders include:
<ul>
<li><code>MCIndexNoder</code> - a fast full-precision noder, which however may not produce 
a valid noding in some situations.
Should be combined with a <code>ValidatingNoder</code> wrapper to detect
noding failures.</li>
<li><code>SnappingNoder</code> - a robust full-precision noder</li>
<li><code>SnapRoundingNoder</code> - a noder which enforces a supplied fixed precision model 
by snapping vertices and intersections to a grid</li>
<li><code>SegmentExtractingNoder</code> - a special-purpose noder that provides very fast noding
for valid polygonal coverages. Requires node-clean input to operate correctly. </li> 
</ul>

<h3>Topology Correction / Conversion</h3>

As noted above, the overlay process
can handle polygonal inputs which are invalid according to the OGC topology model
in certain limited ways.
These invalid conditions are:
  <ul>
  <li>rings which self-touch at discrete points (sometimes called inverted shells and exverted holes).</li>
  <li>rings which touch along line segments (i.e. topology collapse).</li>
  </ul>
These invalidities are corrected during the overlay process.</li>
<p>
Some of these invalidities are considered as valid in other geometry models.
By peforming a self-overlay these inputs can be converted
into the JTS OGC topological model.

<h3>Codebase</h3>
<ul>
<li>Defines a simple, full-featured topology model, with clear semantics.
The topology model incorporates handling topology collapse, which is
essential for snapping and fixed-precision noding.</li>
<li>Uses a simple topology graph data structure (based on the winged edge pattern).</li>
<li>Decouples noding and topology-build phases.
This makes the code clearer, and makes it possible
to allow supplying alternate implementations and semantics for each phase.</li>
<li>All optimizations are implemented internally,
so that clients do not have to add checks such as envelope overlap<./li>
</ul>
</p>
<h2>Algorithm</h2>
For non-point inputs the overlay algorithm is:
<p>
<ol>
<li>Check for empty input geometries, and return a result appropriate for the specified operation
<li>Extract linework and points from input geometries, with topology location information
<li>(If optimization enabled) Apply overlap envelope optimizations:
  <ol>
  <li>For Intersection, check if the input envelopes are disjoint 
      (using an envelope expansion adjustment to account for the precision grid).  
  <li>For Intersection and Difference, clip or limit the linework of the input geometries to the overlap envelope.  
  <li>If the optimized linework is empty, return an empty result of appropriate type. 
  </ol>
<li>Node the linework.  For full robustness snap-rounding noding is used. 
Other kinds of noder can be used as well (for instance, the full-precision noding algorithm as the original overlay code).
<li>Merge noded edges.  
    Coincident edges from the two input geometries are merged, along with their topological labelling. 
    Topology collapses are detected in this step, and are flagged in the labelling so they can be handled appropriately duing result polygon extraction
<li>Build a fully-labelled topology graph.  This includes:
  <ol>
  <li>Create a graph structure on the noded, merged edges
  <li>Propagate topology locations around nodes in the graph
  <li>Label edges that have incomplete topology locations.  
      These occur when edges from an input geometry are isolated (disjoint from the edges of the other geometry in the graph).
  </ol>
<li>If result is empty return an empty geometry of appropriate type
<li>Generate the result geometry from the labelled graph:
  <ol>
  <li>Build result polygons
    <ol>
    <li>Mark edges which should be included in the result areas
    <li>Link maximal rings together
    <li>Convert maximal rings to minimal (valid) rings
    <li>Determine nesting of holes
    <li>Construct result polygons 
    </ol>
  <li>Build result linework
    <ol>
    <li>Mark edges to be included in the result lines
    <li>Extract edges as lines
    </ol>
  <li>Build result points (certain intersection situations only)
    <ol>
    <li>Output points occur where the inputs touch at single points
    </ol>
  <li>Collect result elements into the result geometry
  </ol>
</ol>

</p>

<h2>Package Specification</h2>

<ul>
  <li><A HREF="http://www.opengis.org/techno/specs.htm">
      OpenGIS Simple Features Specification for SQL</A>
</ul></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">org.locationtech.jts:jts-core 1.18.0</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/locationtech/jts/operation/overlay/validate/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../org/locationtech/jts/operation/polygonize/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/locationtech/jts/operation/overlayng/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2020. All rights reserved.</small></p>
</body>
</html>
